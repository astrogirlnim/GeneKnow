name: üöÄ Release Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'desktop/**'
      - 'langgraph/**'
      - '.github/workflows/release.yml'
      - 'package.json'
      - 'README.md'
      - '*.py'
      - 'requirements.txt'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  NODE_VERSION: '20'
  RUST_VERSION: '1.88.0'
  PNPM_VERSION: '10.12.1'

jobs:
  # üè∑Ô∏è Version Management
  version:
    name: üè∑Ô∏è Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: üîß Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üì¶ Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: üè∑Ô∏è Calculate new version
        id: version
        run: |
          echo "üîç Starting automatic version calculation..."
          
          # Get current version from tauri.conf.json (primary source)
          CURRENT_VERSION=$(cat desktop/src-tauri/tauri.conf.json | jq -r '.version')
          echo "üìã Current version from tauri.conf.json: $CURRENT_VERSION"
          
          # Verify consistency with package.json
          PACKAGE_VERSION=$(cat desktop/ui/package.json | jq -r '.version')
          echo "üìã Package.json version: $PACKAGE_VERSION"
          
          if [ "$CURRENT_VERSION" != "$PACKAGE_VERSION" ]; then
            echo "‚ö†Ô∏è  Version mismatch detected!"
            echo "Using tauri.conf.json version: $CURRENT_VERSION"
          fi
          
          # Determine version bump type
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          if [ -z "$VERSION_TYPE" ]; then
            VERSION_TYPE="patch"
            echo "üéØ No version type specified, defaulting to patch"
          fi
          echo "üìà Version bump type: $VERSION_TYPE"
          
          # Parse current version (format: x.y.z)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          echo "üìä Current version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"
          
          # Calculate new version based on type
          case "$VERSION_TYPE" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              echo "üöÄ Major version bump: $MAJOR.$MINOR.$PATCH ‚Üí $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              echo "‚ú® Minor version bump: $MAJOR.$MINOR.$PATCH ‚Üí $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
            "patch"|*)
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              echo "üîß Patch version bump: $MAJOR.$MINOR.$PATCH ‚Üí $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
          esac
          
          NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          NEW_TAG="v$NEW_VERSION"
          
          echo "üéØ New version: $NEW_VERSION"
          echo "üè∑Ô∏è New tag: $NEW_TAG"
          
          # Enhanced tag conflict detection and resolution
          echo "üîç Checking for tag conflicts..."
          
          # Check local tags
          if git tag -l | grep -q "^$NEW_TAG$"; then
            echo "‚ö†Ô∏è  Local tag $NEW_TAG already exists!"
            LOCAL_TAG_COMMIT=$(git rev-parse "$NEW_TAG")
            echo "üìç Local tag points to commit: $LOCAL_TAG_COMMIT"
            echo "üîÑ Force incrementing patch version to resolve conflict..."
            NEW_PATCH=$((NEW_PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            NEW_TAG="v$NEW_VERSION"
            echo "üéØ Conflict resolved - New version: $NEW_VERSION"
          fi
          
          # Check remote tags
          if git ls-remote --tags origin | grep -q "refs/tags/$NEW_TAG$"; then
            echo "‚ö†Ô∏è  Remote tag $NEW_TAG already exists!"
            REMOTE_TAG_COMMIT=$(git ls-remote --tags origin | grep "refs/tags/$NEW_TAG$" | cut -f1)
            echo "üìç Remote tag points to commit: $REMOTE_TAG_COMMIT"
            echo "üîÑ Force incrementing patch version to resolve conflict..."
            NEW_PATCH=$((NEW_PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            NEW_TAG="v$NEW_VERSION"
            echo "üéØ Conflict resolved - New version: $NEW_VERSION"
          fi
          
          # Double-check that the final tag doesn't exist
          if git tag -l | grep -q "^$NEW_TAG$" || git ls-remote --tags origin | grep -q "refs/tags/$NEW_TAG$"; then
            echo "‚ùå Even after conflict resolution, tag $NEW_TAG still exists!"
            echo "üîÑ Using timestamp-based version to ensure uniqueness..."
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH-$TIMESTAMP"
            NEW_TAG="v$NEW_VERSION"
            echo "üéØ Emergency version: $NEW_VERSION"
          fi
          
          # Update tauri.conf.json
          echo "üìù Updating tauri.conf.json..."
          jq --arg version "$NEW_VERSION" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "‚úÖ Updated tauri.conf.json to version $NEW_VERSION"
          
          # Update package.json
          echo "üìù Updating package.json..."
          jq --arg version "$NEW_VERSION" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "‚úÖ Updated package.json to version $NEW_VERSION"
          
          # Generate changelog
          echo "üìã Generating changelog..."
          
          # Get commit messages since last tag
          LAST_TAG=$(git tag -l --sort=-version:refname | head -1)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="HEAD~10"  # If no tags, get last 10 commits
          fi
          
          COMMITS=$(git log --oneline --no-merges "$LAST_TAG"..HEAD --pretty=format:"- %s" | head -20)
          
          CHANGELOG=$(cat << EOF
          ## üß¨ GenePredict Release $NEW_VERSION
          
          ### üìã What's New
          - Automated release build for desktop application
          - Cross-platform builds (macOS, Windows, Linux)
          - Privacy-first genomic risk assessment platform
          
          ### üîÑ Changes Since Last Release
          $COMMITS
          
          ### üî® Technical Details
          - **Version**: $NEW_VERSION
          - **Version Type**: $VERSION_TYPE
          - **Previous Version**: $CURRENT_VERSION
          - **Tauri**: 2.6.2
          - **React**: 19.1.0
          - **TypeScript**: 5.8.3
          
          ### üì¶ Download
          Choose the appropriate installer for your platform below.
          EOF
          )
          
          # Set outputs
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Version calculation completed successfully!"

      - name: üßπ Clean up existing release if exists
        run: |
          echo "üßπ Checking for existing release..."
          if gh release view ${{ steps.version.outputs.tag }} >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Release ${{ steps.version.outputs.tag }} already exists. Deleting..."
            gh release delete ${{ steps.version.outputs.tag }} --yes
            echo "‚úÖ Existing release deleted"
          else
            echo "‚úÖ No existing release found"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üì§ Create and push git tag
        run: |
          echo "üì§ Creating and pushing git tag..."
          
          # Enhanced tag conflict detection and resolution
          TAG_NAME="${{ steps.version.outputs.tag }}"
          
          # Check for local tag conflicts
          if git tag -l | grep -q "^$TAG_NAME$"; then
            echo "üßπ Found existing local tag: $TAG_NAME"
            LOCAL_TAG_COMMIT=$(git rev-parse "$TAG_NAME")
            echo "üìç Local tag points to commit: $LOCAL_TAG_COMMIT"
            
            # Delete local tag
            git tag -d "$TAG_NAME"
            echo "‚úÖ Deleted local tag: $TAG_NAME"
          fi
          
          # Check for remote tag conflicts
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "üßπ Found existing remote tag: $TAG_NAME"
            REMOTE_TAG_COMMIT=$(git ls-remote --tags origin | grep "refs/tags/$TAG_NAME$" | cut -f1)
            echo "üìç Remote tag points to commit: $REMOTE_TAG_COMMIT"
            
            # Delete remote tag with error handling
            if git push origin ":refs/tags/$TAG_NAME" 2>/dev/null; then
              echo "‚úÖ Deleted remote tag: $TAG_NAME"
            else
              echo "‚ö†Ô∏è  Failed to delete remote tag, continuing anyway..."
            fi
          fi
          
          # Wait a moment for tag deletion to propagate
          sleep 2
          
          # Create and push new tag with retry logic
          echo "üì§ Creating new tag: $TAG_NAME"
          git tag "$TAG_NAME"
          
          # Push with retry logic
          for i in {1..3}; do
            if git push origin "$TAG_NAME"; then
              echo "‚úÖ Successfully pushed tag: $TAG_NAME (attempt $i)"
              break
            else
              echo "‚ö†Ô∏è  Failed to push tag (attempt $i), retrying in 5 seconds..."
              sleep 5
              if [ $i -eq 3 ]; then
                echo "‚ùå Failed to push tag after 3 attempts"
                exit 1
              fi
            fi
          done
          
          # Verify tag was pushed correctly
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "‚úÖ Tag successfully created and pushed: $TAG_NAME"
          else
            echo "‚ùå Tag verification failed - tag not found on remote"
            exit 1
          fi
          
          echo "‚ÑπÔ∏è  Note: Version files are updated locally for build process only"
          echo "‚ÑπÔ∏è  Use ./scripts/bump-version.sh to update version files in repository"

  # üß™ Validation & Testing
  validate:
    name: üß™ Validation & Testing
    needs: version
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: üîÑ Update version files for validation
        shell: bash
        run: |
          echo "üîÑ Updating version files to ${{ needs.version.outputs.version }}..."
          
          # Update tauri.conf.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "‚úÖ Updated tauri.conf.json"
          
          # Update package.json  
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "‚úÖ Updated package.json"
          
          echo "üéØ Version files updated for validation process"

      - name: üîß Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üì¶ Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: üîç Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: üöÄ Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: üì¶ Install frontend dependencies
        working-directory: desktop/ui
        run: |
          echo "üì¶ Installing dependencies for validation..."
          pnpm install --frozen-lockfile
          echo "‚úÖ Dependencies installed"

      - name: üîç Run validation checks
        working-directory: desktop/ui
        run: |
          echo "üîç Running ESLint..."
          pnpm lint
          echo "‚úÖ ESLint passed"
          
          echo "üîç Running TypeScript check..."
          pnpm exec tsc --noEmit
          echo "‚úÖ TypeScript check passed"
          
          echo "üî® Building frontend..."
          pnpm build
          echo "‚úÖ Frontend build successful"

  # üî® Build Multi-Platform Release
  build:
    name: üî® Build Release
    needs: [version]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - os: ubuntu-latest
            rust-target: x86_64-unknown-linux-gnu
            name: 'Linux x64'
            emoji: 'üêß'
          - os: windows-latest
            rust-target: x86_64-pc-windows-msvc
            name: 'Windows x64'
            emoji: 'ü™ü'
          - os: macos-latest
            rust-target: x86_64-apple-darwin
            name: 'macOS x64'
            emoji: 'üçé'

    runs-on: ${{ matrix.platform.os }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: üîÑ Update version files for build
        shell: bash
        run: |
          echo "üîÑ Updating version files to ${{ needs.version.outputs.version }}..."
          
          # Update tauri.conf.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "‚úÖ Updated tauri.conf.json"
          
          # Update package.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "‚úÖ Updated package.json"
          
          echo "üéØ Version files updated for build process"

      - name: üîß Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üì¶ Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: ü¶Ä Setup Rust ${{ env.RUST_VERSION }}
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: ${{ matrix.platform.rust-target }}

      - name: üöÄ Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            desktop/src-tauri -> target

      - name: üîç Cache Tauri CLI
        uses: actions/cache@v4
        id: tauri-cli-cache
        with:
          path: |
            ~/.cargo/bin/cargo-tauri
            ~/.cargo/bin/cargo-tauri.exe
          key: ${{ runner.os }}-tauri-cli-${{ env.RUST_VERSION }}
          restore-keys: |
            ${{ runner.os }}-tauri-cli-

      - name: üì¶ Install Tauri CLI
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: |
          echo "üì¶ Installing Tauri CLI..."
          cargo install tauri-cli --locked
          echo "‚úÖ Tauri CLI installed successfully"

      - name: üîç Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: üöÄ Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: üîß Install system dependencies (Linux)
        if: matrix.platform.os == 'ubuntu-latest'
        run: |
          echo "üîß Installing Linux system dependencies..."
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev librsvg2-dev
          echo "‚úÖ Linux dependencies installed"

      - name: üì¶ Install frontend dependencies
        working-directory: desktop/ui
        run: |
          echo "üì¶ Installing frontend dependencies..."
          pnpm install --frozen-lockfile
          echo "‚úÖ Frontend dependencies installed"

      - name: üî® Build frontend
        working-directory: desktop/ui
        run: |
          echo "üî® Building frontend for release..."
          pnpm build
          echo "‚úÖ Frontend build completed"

      - name: üî® Build Tauri Release
        working-directory: desktop/src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          echo "${{ matrix.platform.emoji }} Building Tauri release for ${{ matrix.platform.name }}..."
          echo "üéØ Target: ${{ matrix.platform.rust-target }}"
          echo "üì¶ Version: ${{ needs.version.outputs.version }}"
          
          cargo tauri build --target ${{ matrix.platform.rust-target }}
          
          echo "‚úÖ Tauri release build completed for ${{ matrix.platform.name }}"

      - name: üìÇ Locate build artifacts (Unix)
        id: artifacts-unix
        if: matrix.platform.os != 'windows-latest'
        run: |
          echo "üìÇ Locating build artifacts..."
          echo "üîç Searching in desktop/src-tauri/target/${{ matrix.platform.rust-target }}/release/bundle/"
          
          # Find all bundle files
          find desktop/src-tauri/target/${{ matrix.platform.rust-target }}/release/bundle/ -type f -name "*" | sort
          
          echo "‚úÖ Build artifacts located"

      - name: üìÇ Locate build artifacts (Windows)
        id: artifacts-windows
        if: matrix.platform.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "üìÇ Locating build artifacts..."
          echo "üîç Searching in desktop/src-tauri/target/${{ matrix.platform.rust-target }}/release/bundle/"
          
          # Find all bundle files using PowerShell
          Get-ChildItem -Path "desktop/src-tauri/target/${{ matrix.platform.rust-target }}/release/bundle/" -Recurse -File | Sort-Object FullName | ForEach-Object { $_.FullName }
          
          echo "‚úÖ Build artifacts located"

      - name: üì§ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform.name }} Build
          path: desktop/src-tauri/target/${{ matrix.platform.rust-target }}/release/bundle/
          if-no-files-found: error

      - name: üìä Build summary
        run: |
          echo "üìä Build completed successfully for ${{ matrix.platform.name }}"
          echo "üéØ Version: ${{ needs.version.outputs.version }}"
          echo "üè∑Ô∏è Tag: ${{ needs.version.outputs.tag }}"
          echo "üì¶ Artifacts uploaded to GitHub Actions"

  # üöÄ Create GitHub Release
  release:
    name: üöÄ Create GitHub Release
    needs: [version, build]
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: üì• Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: üìÇ List artifacts
        run: |
          echo "üìÇ Downloaded artifacts:"
          find ./artifacts -type f -name "*" | sort

      - name: üóÇÔ∏è Organize artifacts by platform
        run: |
          echo "üóÇÔ∏è Organizing artifacts to prevent name conflicts..."
          mkdir -p ./release-assets
          
          # Move Linux artifacts with platform prefix
          if [ -d "./artifacts/Linux x64 Build" ]; then
            echo "üì¶ Processing Linux artifacts..."
            find "./artifacts/Linux x64 Build" -name "*.deb" -exec cp {} ./release-assets/ \;
            find "./artifacts/Linux x64 Build" -name "*.rpm" -exec cp {} ./release-assets/ \;
            find "./artifacts/Linux x64 Build" -name "*.AppImage" -exec cp {} ./release-assets/ \;
          fi
          
          # Move Windows artifacts with platform prefix
          if [ -d "./artifacts/Windows x64 Build" ]; then
            echo "üì¶ Processing Windows artifacts..."
            find "./artifacts/Windows x64 Build" -name "*.msi" -exec cp {} ./release-assets/ \;
            find "./artifacts/Windows x64 Build" -name "*.exe" -exec cp {} ./release-assets/ \;
          fi
          
          # Move macOS artifacts with platform prefix
          if [ -d "./artifacts/macOS x64 Build" ]; then
            echo "üì¶ Processing macOS artifacts..."
            find "./artifacts/macOS x64 Build" -name "*.dmg" -exec cp {} ./release-assets/ \;
            find "./artifacts/macOS x64 Build" -name "*.app" -exec cp {} ./release-assets/ \;
          fi
          
          echo "‚úÖ Organized release assets:"
          ls -la ./release-assets/

      - name: üöÄ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: üß¨ GenePredict ${{ needs.version.outputs.version }}
          body: ${{ needs.version.outputs.changelog }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            ./release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üìã Release summary
        run: |
          echo "# üß¨ GenePredict Release ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üéâ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üì¶ Available Downloads" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- üêß **Linux**: .deb and .AppImage installers" >> $GITHUB_STEP_SUMMARY
          echo "- ü™ü **Windows**: .msi and .exe installers" >> $GITHUB_STEP_SUMMARY
          echo "- üçé **macOS**: .dmg installer (Universal Binary)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîó Links" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [üìÑ Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.version.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
          echo "- [üì• Download Page](https://github.com/${{ github.repository }}/releases/latest)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "üß¨ **GenePredict** - Privacy-First Genomic Risk Assessment Platform" >> $GITHUB_STEP_SUMMARY 