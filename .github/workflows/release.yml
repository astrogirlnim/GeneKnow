name: ðŸš€ Release Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'desktop/**'
      - 'langgraph/**'
      - '.github/workflows/release.yml'
      - 'package.json'
      - 'README.md'
      - '*.py'
      - 'requirements.txt'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

env:
  NODE_VERSION: '20'
  RUST_VERSION: '1.88.0'
  PNPM_VERSION: '10.12.1'

jobs:
  # ðŸ§¹ Cleanup old artifacts to free storage
  cleanup:
    name: ðŸ§¹ Cleanup Old Artifacts
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ§¹ Delete old artifacts (ULTRA AGGRESSIVE)
        uses: actions/github-script@v7
        with:
          script: |
            console.log('ðŸ§¹ Starting ULTRA AGGRESSIVE artifact cleanup to free storage...');
            
            // Get all artifacts
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            console.log(`ðŸ“Š Found ${artifacts.data.total_count} artifacts`);
            
            // Sort artifacts by creation date (newest first)
            const sortedArtifacts = artifacts.data.artifacts.sort((a, b) => 
              new Date(b.created_at) - new Date(a.created_at)
            );
            
            // ULTRA AGGRESSIVE CLEANUP: Keep only the SINGLE most recent artifact
            let deletedCount = 0;
            let preservedCount = 0;
            let totalSizeFreed = 0;
            
            for (let i = 0; i < sortedArtifacts.length; i++) {
              const artifact = sortedArtifacts[i];
              const sizeMB = Math.round(artifact.size_in_bytes / 1024 / 1024);
              
              if (i < 1) {
                // Keep only the SINGLE most recent artifact
                console.log(`ðŸ”’ Keeping artifact: ${artifact.name} (${sizeMB}MB) - Most recent artifact`);
                preservedCount++;
              } else {
                // Delete ALL other artifacts
                console.log(`ðŸ—‘ï¸  Deleting artifact: ${artifact.name} (${sizeMB}MB)`);
                try {
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id
                  });
                  deletedCount++;
                  totalSizeFreed += sizeMB;
                } catch (error) {
                  console.log(`âš ï¸  Failed to delete ${artifact.name}: ${error.message}`);
                }
              }
            }
            
            console.log(`âœ… ULTRA AGGRESSIVE cleanup completed!`);
            console.log(`ðŸ—‘ï¸  Deleted ${deletedCount} artifacts`);
            console.log(`ðŸ’¾ Freed approximately ${totalSizeFreed}MB of storage`);
            console.log(`ðŸ”’ Preserved ${preservedCount} recent artifact`);
            console.log(`ðŸš€ Maximum storage now available for new builds`);

  # ðŸ·ï¸ Version Management
  version:
    name: ðŸ·ï¸ Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: ðŸ”§ Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ“¦ Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: ðŸ·ï¸ Calculate new version
        id: version
        run: |
          echo "ðŸ” Starting automatic version calculation..."
          
          # Get current version from tauri.conf.json (primary source)
          CURRENT_VERSION=$(cat desktop/src-tauri/tauri.conf.json | jq -r '.version')
          echo "ðŸ“‹ Current version from tauri.conf.json: $CURRENT_VERSION"
          
          # Verify consistency with package.json
          PACKAGE_VERSION=$(cat desktop/ui/package.json | jq -r '.version')
          echo "ðŸ“‹ Package.json version: $PACKAGE_VERSION"
          
          if [ "$CURRENT_VERSION" != "$PACKAGE_VERSION" ]; then
            echo "âš ï¸  Version mismatch detected!"
            echo "Using tauri.conf.json version: $CURRENT_VERSION"
          fi
          
          # Determine version bump type
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          if [ -z "$VERSION_TYPE" ]; then
            VERSION_TYPE="patch"
            echo "ðŸŽ¯ No version type specified, defaulting to patch"
          fi
          echo "ðŸ“ˆ Version bump type: $VERSION_TYPE"
          
          # Parse current version (format: x.y.z)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          echo "ðŸ“Š Current version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"
          
          # Calculate new version based on type
          case "$VERSION_TYPE" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              echo "ðŸš€ Major version bump: $MAJOR.$MINOR.$PATCH â†’ $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              echo "âœ¨ Minor version bump: $MAJOR.$MINOR.$PATCH â†’ $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
            "patch"|*)
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              echo "ðŸ”§ Patch version bump: $MAJOR.$MINOR.$PATCH â†’ $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
          esac
          
          NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          NEW_TAG="v$NEW_VERSION"
          
          echo "ðŸŽ¯ New version: $NEW_VERSION"
          echo "ðŸ·ï¸ New tag: $NEW_TAG"
          
          # Enhanced tag conflict detection and resolution
          echo "ðŸ” Checking for tag conflicts..."
          
          # Check local tags
          if git tag -l | grep -q "^$NEW_TAG$"; then
            echo "âš ï¸  Local tag $NEW_TAG already exists!"
            LOCAL_TAG_COMMIT=$(git rev-parse "$NEW_TAG")
            echo "ðŸ“ Local tag points to commit: $LOCAL_TAG_COMMIT"
            echo "ðŸ”„ Force incrementing patch version to resolve conflict..."
            NEW_PATCH=$((NEW_PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            NEW_TAG="v$NEW_VERSION"
            echo "ðŸŽ¯ Conflict resolved - New version: $NEW_VERSION"
          fi
          
          # Check remote tags
          if git ls-remote --tags origin | grep -q "refs/tags/$NEW_TAG$"; then
            echo "âš ï¸  Remote tag $NEW_TAG already exists!"
            REMOTE_TAG_COMMIT=$(git ls-remote --tags origin | grep "refs/tags/$NEW_TAG$" | cut -f1)
            echo "ðŸ“ Remote tag points to commit: $REMOTE_TAG_COMMIT"
            echo "ðŸ”„ Force incrementing patch version to resolve conflict..."
            NEW_PATCH=$((NEW_PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            NEW_TAG="v$NEW_VERSION"
            echo "ðŸŽ¯ Conflict resolved - New version: $NEW_VERSION"
          fi
          
          # Double-check that the final tag doesn't exist
          if git tag -l | grep -q "^$NEW_TAG$" || git ls-remote --tags origin | grep -q "refs/tags/$NEW_TAG$"; then
            echo "âŒ Even after conflict resolution, tag $NEW_TAG still exists!"
            echo "ðŸ”„ Using timestamp-based version to ensure uniqueness..."
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH-$TIMESTAMP"
            NEW_TAG="v$NEW_VERSION"
            echo "ðŸŽ¯ Emergency version: $NEW_VERSION"
          fi
          
          # Update tauri.conf.json
          echo "ðŸ“ Updating tauri.conf.json..."
          jq --arg version "$NEW_VERSION" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "âœ… Updated tauri.conf.json to version $NEW_VERSION"
          
          # Update package.json
          echo "ðŸ“ Updating package.json..."
          jq --arg version "$NEW_VERSION" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "âœ… Updated package.json to version $NEW_VERSION"
          
          # Generate changelog
          echo "ðŸ“‹ Generating changelog..."
          
          # Get commit messages since last tag
          LAST_TAG=$(git tag -l --sort=-version:refname | head -1)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="HEAD~10"  # If no tags, get last 10 commits
          fi
          
          COMMITS=$(git log --oneline --no-merges "$LAST_TAG"..HEAD --pretty=format:"- %s" | head -20)
          
          CHANGELOG=$(cat << EOF
          ## ðŸ§¬ GenePredict Release $NEW_VERSION
          
          ### ðŸ“‹ What's New
          - Automated release build for desktop application
          - Cross-platform builds (macOS, Windows, Linux)
          - Privacy-first genomic risk assessment platform
          
          ### ðŸ”„ Changes Since Last Release
          $COMMITS
          
          ### ðŸ”¨ Technical Details
          - **Version**: $NEW_VERSION
          - **Version Type**: $VERSION_TYPE
          - **Previous Version**: $CURRENT_VERSION
          - **Tauri**: 2.6.2
          - **React**: 19.1.0
          - **TypeScript**: 5.8.3
          
          ### ðŸ“¦ Download
          Choose the appropriate installer for your platform below.
          EOF
          )
          
          # Set outputs
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "âœ… Version calculation completed successfully!"

      - name: ðŸ§¹ Clean up existing release if exists
        run: |
          echo "ðŸ§¹ Checking for existing release..."
          if gh release view ${{ steps.version.outputs.tag }} >/dev/null 2>&1; then
            echo "âš ï¸  Release ${{ steps.version.outputs.tag }} already exists. Deleting..."
            gh release delete ${{ steps.version.outputs.tag }} --yes
            echo "âœ… Existing release deleted"
          else
            echo "âœ… No existing release found"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“¤ Create and push git tag
        run: |
          echo "ðŸ“¤ Creating and pushing git tag..."
          
          # Enhanced tag conflict detection and resolution
          TAG_NAME="${{ steps.version.outputs.tag }}"
          
          # Check for local tag conflicts
          if git tag -l | grep -q "^$TAG_NAME$"; then
            echo "ðŸ§¹ Found existing local tag: $TAG_NAME"
            LOCAL_TAG_COMMIT=$(git rev-parse "$TAG_NAME")
            echo "ðŸ“ Local tag points to commit: $LOCAL_TAG_COMMIT"
            
            # Delete local tag
            git tag -d "$TAG_NAME"
            echo "âœ… Deleted local tag: $TAG_NAME"
          fi
          
          # Check for remote tag conflicts
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "ðŸ§¹ Found existing remote tag: $TAG_NAME"
            REMOTE_TAG_COMMIT=$(git ls-remote --tags origin | grep "refs/tags/$TAG_NAME$" | cut -f1)
            echo "ðŸ“ Remote tag points to commit: $REMOTE_TAG_COMMIT"
            
            # Delete remote tag with error handling
            if git push origin ":refs/tags/$TAG_NAME" 2>/dev/null; then
              echo "âœ… Deleted remote tag: $TAG_NAME"
            else
              echo "âš ï¸  Failed to delete remote tag, continuing anyway..."
            fi
          fi
          
          # Wait a moment for tag deletion to propagate
          sleep 2
          
          # Create and push new tag with retry logic
          echo "ðŸ“¤ Creating new tag: $TAG_NAME"
          git tag "$TAG_NAME"
          
          # Push with retry logic
          for i in {1..3}; do
            if git push origin "$TAG_NAME"; then
              echo "âœ… Successfully pushed tag: $TAG_NAME (attempt $i)"
              break
            else
              echo "âš ï¸  Failed to push tag (attempt $i), retrying in 5 seconds..."
              sleep 5
              if [ $i -eq 3 ]; then
                echo "âŒ Failed to push tag after 3 attempts"
                exit 1
              fi
            fi
          done
          
          # Verify tag was pushed correctly
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "âœ… Tag successfully created and pushed: $TAG_NAME"
          else
            echo "âŒ Tag verification failed - tag not found on remote"
            exit 1
          fi
          
          echo "â„¹ï¸  Note: Version files are updated locally for build process only"
          echo "â„¹ï¸  Use ./scripts/bump-version.sh to update version files in repository"

  # ðŸ” Platform Change Detection
  detect-changes:
    name: ðŸ” Detect Platform Changes
    runs-on: ubuntu-latest
    outputs:
      build-linux: ${{ steps.changes.outputs.linux }}
      build-windows: ${{ steps.changes.outputs.windows }}
      build-macos: ${{ steps.changes.outputs.macos }}
      build-all: ${{ steps.changes.outputs.all }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” Detect platform-specific changes
        id: changes
        run: |
          echo "ðŸ” Analyzing changes to determine which platforms need rebuilding..."
          
          # Get the list of changed files since last tag
          LAST_TAG=$(git tag -l --sort=-version:refname | head -1)
          if [ -z "$LAST_TAG" ]; then
            echo "No previous tag found, building all platforms"
            echo "linux=true" >> $GITHUB_OUTPUT
            echo "windows=true" >> $GITHUB_OUTPUT
            echo "macos=true" >> $GITHUB_OUTPUT
            echo "all=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ðŸ“Š Comparing changes since: $LAST_TAG"
          CHANGED_FILES=$(git diff --name-only $LAST_TAG..HEAD)
          
          # Check for core changes that affect all platforms
          CORE_CHANGES=$(echo "$CHANGED_FILES" | grep -E "(desktop/src-tauri/|desktop/ui/|\.github/workflows/release\.yml)" | wc -l)
          
          # Check for platform-specific changes
          LINUX_CHANGES=$(echo "$CHANGED_FILES" | grep -E "(\.deb|\.AppImage|linux)" | wc -l)
          WINDOWS_CHANGES=$(echo "$CHANGED_FILES" | grep -E "(\.msi|\.exe|windows)" | wc -l)
          MACOS_CHANGES=$(echo "$CHANGED_FILES" | grep -E "(\.dmg|macos|darwin)" | wc -l)
          
          echo "ðŸ“‹ Change Analysis:"
          echo "  Core changes: $CORE_CHANGES files"
          echo "  Linux-specific: $LINUX_CHANGES files"
          echo "  Windows-specific: $WINDOWS_CHANGES files"
          echo "  macOS-specific: $MACOS_CHANGES files"
          
          # Determine which platforms to build
          if [ $CORE_CHANGES -gt 0 ]; then
            echo "ðŸ”¨ Core changes detected - building all platforms"
            echo "linux=true" >> $GITHUB_OUTPUT
            echo "windows=true" >> $GITHUB_OUTPUT
            echo "macos=true" >> $GITHUB_OUTPUT
            echo "all=true" >> $GITHUB_OUTPUT
          else
            echo "ðŸŽ¯ Platform-specific changes detected"
            echo "linux=$([[ $LINUX_CHANGES -gt 0 ]] && echo true || echo false)" >> $GITHUB_OUTPUT
            echo "windows=$([[ $WINDOWS_CHANGES -gt 0 ]] && echo true || echo false)" >> $GITHUB_OUTPUT
            echo "macos=$([[ $MACOS_CHANGES -gt 0 ]] && echo true || echo false)" >> $GITHUB_OUTPUT
            echo "all=false" >> $GITHUB_OUTPUT
          fi

  # ðŸ§ª Validation & Testing
  validate:
    name: ðŸ§ª Validation & Testing
    needs: [version, detect-changes]
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: ðŸ”„ Update version files for validation
        shell: bash
        run: |
          echo "ðŸ”„ Updating version files to ${{ needs.version.outputs.version }}..."
          
          # Update tauri.conf.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "âœ… Updated tauri.conf.json"
          
          # Update package.json  
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "âœ… Updated package.json"
          
          echo "ðŸŽ¯ Version files updated for validation process"

      - name: ðŸ”§ Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ“¦ Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: ðŸ” Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: ðŸš€ Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: ðŸ“¦ Install frontend dependencies
        working-directory: desktop/ui
        run: |
          echo "ðŸ“¦ Installing dependencies for validation..."
          pnpm install --frozen-lockfile
          echo "âœ… Dependencies installed"

      - name: ðŸ” Run validation checks
        working-directory: desktop/ui
        run: |
          echo "ðŸ” Running ESLint..."
          pnpm lint
          echo "âœ… ESLint passed"
          
          echo "ðŸ” Running TypeScript check..."
          pnpm exec tsc --noEmit
          echo "âœ… TypeScript check passed"
          
          echo "ðŸ”¨ Building frontend..."
          pnpm build
          echo "âœ… Frontend build successful"

  # ðŸ”¨ Build Multi-Platform Release
  build:
    name: ðŸ”¨ Build Release
    needs: [cleanup, version, detect-changes]
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            rust-target: x86_64-unknown-linux-gnu
            name: 'Linux x64'
            emoji: 'ðŸ§'
            build-key: 'linux'
          - os: windows-latest
            rust-target: x86_64-pc-windows-msvc
            name: 'Windows x64'
            emoji: 'ðŸªŸ'
            build-key: 'windows'
          - os: macos-latest
            rust-target: x86_64-apple-darwin
            name: 'macOS x64'
            emoji: 'ðŸŽ'
            build-key: 'macos'
    runs-on: ${{ matrix.os }}
    steps:
      - name: ðŸ” Check if platform needs building
        id: should-build
        shell: bash
        run: |
          BUILD_ALL="${{ needs.detect-changes.outputs.build-all }}"
          BUILD_LINUX="${{ needs.detect-changes.outputs.build-linux }}"
          BUILD_WINDOWS="${{ needs.detect-changes.outputs.build-windows }}"
          BUILD_MACOS="${{ needs.detect-changes.outputs.build-macos }}"
          PLATFORM="${{ matrix.build-key }}"
          
          echo "ðŸ” Platform: $PLATFORM"
          echo "ðŸ“Š Build signals - All: $BUILD_ALL, Linux: $BUILD_LINUX, Windows: $BUILD_WINDOWS, macOS: $BUILD_MACOS"
          
          SHOULD_BUILD="false"
          if [ "$BUILD_ALL" = "true" ]; then
            SHOULD_BUILD="true"
            echo "âœ… Building $PLATFORM - core changes detected"
          elif [ "$PLATFORM" = "linux" ] && [ "$BUILD_LINUX" = "true" ]; then
            SHOULD_BUILD="true"
            echo "âœ… Building $PLATFORM - Linux-specific changes detected"
          elif [ "$PLATFORM" = "windows" ] && [ "$BUILD_WINDOWS" = "true" ]; then
            SHOULD_BUILD="true"
            echo "âœ… Building $PLATFORM - Windows-specific changes detected"
          elif [ "$PLATFORM" = "macos" ] && [ "$BUILD_MACOS" = "true" ]; then
            SHOULD_BUILD="true"
            echo "âœ… Building $PLATFORM - macOS-specific changes detected"
          else
            echo "â­ï¸ Skipping $PLATFORM - no relevant changes detected"
          fi
          
          echo "should-build=$SHOULD_BUILD" >> $GITHUB_OUTPUT

      - name: ðŸ“¥ Checkout code
        if: steps.should-build.outputs.should-build == 'true'
        uses: actions/checkout@v4
        with:
          ref: main

      - name: ðŸ”„ Update version files for build
        if: steps.should-build.outputs.should-build == 'true'
        shell: bash
        run: |
          echo "ðŸ”„ Updating version files to ${{ needs.version.outputs.version }}..."
          
          # Update tauri.conf.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "âœ… Updated tauri.conf.json"
          
          # Update package.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "âœ… Updated package.json"
          
          echo "ðŸŽ¯ Version files updated for build process"

      - name: ðŸ”§ Setup Node.js ${{ env.NODE_VERSION }}
        if: steps.should-build.outputs.should-build == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ“¦ Install pnpm
        if: steps.should-build.outputs.should-build == 'true'
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: ðŸ¦€ Setup Rust ${{ env.RUST_VERSION }}
        if: steps.should-build.outputs.should-build == 'true'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: ${{ matrix.rust-target }}

      - name: ðŸš€ Rust cache
        if: steps.should-build.outputs.should-build == 'true'
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            desktop/src-tauri -> target

      - name: ðŸ” Cache Tauri CLI
        uses: actions/cache@v4
        id: tauri-cli-cache
        with:
          path: |
            ~/.cargo/bin/cargo-tauri
            ~/.cargo/bin/cargo-tauri.exe
          key: ${{ runner.os }}-tauri-cli-${{ env.RUST_VERSION }}
          restore-keys: |
            ${{ runner.os }}-tauri-cli-

      - name: ðŸ“¦ Install Tauri CLI
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: |
          echo "ðŸ“¦ Installing Tauri CLI..."
          cargo install tauri-cli --locked
          echo "âœ… Tauri CLI installed successfully"

      - name: ðŸ” Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: ðŸš€ Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: ðŸ”§ Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          echo "ðŸ”§ Installing Linux system dependencies..."
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev librsvg2-dev
          echo "âœ… Linux dependencies installed"

      - name: ðŸ“¦ Install frontend dependencies
        working-directory: desktop/ui
        run: |
          echo "ðŸ“¦ Installing frontend dependencies..."
          pnpm install --frozen-lockfile
          echo "âœ… Frontend dependencies installed"

      - name: ðŸ”¨ Build frontend
        working-directory: desktop/ui
        run: |
          echo "ðŸ”¨ Building frontend for release..."
          pnpm build
          echo "âœ… Frontend build completed"

      - name: ðŸ”¨ Build Tauri Release
        working-directory: desktop/src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          echo "${{ matrix.emoji }} Building Tauri release for ${{ matrix.name }}..."
          echo "ðŸŽ¯ Target: ${{ matrix.rust-target }}"
          echo "ðŸ“¦ Version: ${{ needs.version.outputs.version }}"
          
          cargo tauri build --target ${{ matrix.rust-target }}
          
          echo "âœ… Tauri release build completed for ${{ matrix.name }}"

      - name: ðŸ“‚ Locate build artifacts (Unix)
        id: artifacts-unix
        if: matrix.os != 'windows-latest'
        run: |
          echo "ðŸ“‚ Locating build artifacts..."
          echo "ðŸ” Searching in desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/"
          
          # Find all bundle files
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -type f -name "*" | sort
          
          echo "âœ… Build artifacts located"

      - name: ðŸ“‚ Locate build artifacts (Windows)
        id: artifacts-windows
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "ðŸ“‚ Locating build artifacts..."
          echo "ðŸ” Searching in desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/"
          
          # Find all bundle files using PowerShell
          Get-ChildItem -Path "desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/" -Recurse -File | Sort-Object FullName | ForEach-Object { $_.FullName }
          
          echo "âœ… Build artifacts located"

      - name: ðŸ“¤ Upload build artifacts
        # Only upload artifacts for tagged releases to save storage
        if: startsWith(github.ref, 'refs/tags/')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-${{ needs.version.outputs.version }}
          path: |
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.dmg
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.msi
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.deb
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.AppImage
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.exe
          if-no-files-found: error
          retention-days: 1
          compression-level: 9

      - name: ðŸ“Š Build summary
        run: |
          echo "ðŸ“Š Build completed successfully for ${{ matrix.name }}"
          echo "ðŸŽ¯ Version: ${{ needs.version.outputs.version }}"
          echo "ðŸ·ï¸ Tag: ${{ needs.version.outputs.tag }}"
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "ðŸ“¦ Artifacts uploaded to GitHub Actions (tagged release)"
            echo "ðŸª Artifacts will be permanently stored in GitHub Release"
          else
            echo "ðŸ“¦ Artifacts built but not uploaded (main branch push - saves storage)"
            echo "ðŸ” Build validation completed without storage usage"
          fi

      - name: ðŸª Store artifacts for release (Direct Storage)
        # For tagged releases, also prepare artifacts for direct release upload
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          echo "ðŸª Preparing artifacts for direct release storage..."
          mkdir -p ./release-ready
          
          # Copy all installer files to release-ready directory
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.dmg" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.msi" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.deb" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.AppImage" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.exe" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          
          echo "âœ… Artifacts prepared for release storage:"
          ls -la ./release-ready/ || echo "No artifacts found"

      - name: ðŸ“¤ Upload release-ready artifacts
        # Upload prepared artifacts for the release job
        if: startsWith(github.ref, 'refs/tags/')
        uses: actions/upload-artifact@v4
        with:
          name: release-ready-${{ matrix.name }}-${{ needs.version.outputs.version }}
          path: ./release-ready/*
          if-no-files-found: warn
          retention-days: 1
          compression-level: 9

  # ðŸš€ Create GitHub Release
  release:
    name: ðŸš€ Create GitHub Release
    needs: [version, build]
    runs-on: ubuntu-latest
    # Only create releases for tagged builds (when artifacts are uploaded)
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: ðŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: "release-ready-*-${{ needs.version.outputs.version }}"
          merge-multiple: true

      - name: ðŸ“‚ List artifacts
        run: |
          echo "ðŸ“‚ Downloaded artifacts:"
          find ./artifacts -type f -name "*" | sort

      - name: ðŸ—‚ï¸ Organize artifacts by platform
        run: |
          echo "ðŸ—‚ï¸ Organizing installer files for release..."
          mkdir -p ./release-assets
          
          # Copy all installer files from artifacts
          find ./artifacts -name "*.dmg" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.msi" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.deb" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.AppImage" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.exe" -exec cp {} ./release-assets/ \;
          
          echo "âœ… Organized installer files:"
          ls -la ./release-assets/
          
          # Verify we have installers for all platforms
          echo "ðŸ“Š Platform coverage:"
          echo "ðŸŽ macOS: $(ls ./release-assets/*.dmg 2>/dev/null | wc -l) installers"
          echo "ðŸªŸ Windows: $(ls ./release-assets/*.msi 2>/dev/null | wc -l) MSI + $(ls ./release-assets/*.exe 2>/dev/null | wc -l) EXE"
          echo "ðŸ§ Linux: $(ls ./release-assets/*.deb 2>/dev/null | wc -l) DEB + $(ls ./release-assets/*.AppImage 2>/dev/null | wc -l) AppImage"

      - name: ðŸš€ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: ðŸ§¬ GenePredict ${{ needs.version.outputs.version }}
          body: ${{ needs.version.outputs.changelog }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            ./release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“‹ Release summary
        run: |
          echo "# ðŸ§¬ GenePredict Release ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸŽ‰ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“¦ Available Downloads" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ§ **Linux**: .deb and .AppImage installers" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸªŸ **Windows**: .msi and .exe installers" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŽ **macOS**: .dmg installer (Universal Binary)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ”— Links" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [ðŸ“„ Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.version.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
          echo "- [ðŸ“¥ Download Page](https://github.com/${{ github.repository }}/releases/latest)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ§¬ **GenePredict** - Privacy-First Genomic Risk Assessment Platform" >> $GITHUB_STEP_SUMMARY 
