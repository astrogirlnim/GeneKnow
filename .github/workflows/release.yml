name: 🚀 Release Pipeline

# This workflow can be triggered in three ways:
# 1. Automatic: Push to main branch or create version tags
# 2. Manual: Workflow dispatch with production release (creates GitHub release)
# 3. Manual: Workflow dispatch with test release (builds artifacts without GitHub release)
#
# Manual trigger options:
# - target_branch: Specify which branch to build from (default: current branch)
# - version_type: patch/minor/major version bump
# - is_test_release: If true, builds artifacts but doesn't create GitHub release or git tags

on:
  push:
    branches: [ main ]
    paths:
      - 'desktop/**'
      - 'geneknow_pipeline/**'  # Add this to trigger on Python pipeline changes
      - 'langgraph/**'
      - '.github/workflows/release.yml'
      - 'package.json'
      - 'README.md'
      - '*.py'
      - 'requirements.txt'
      - 'requirements-lite.txt'  # Add this for optimized requirements
      - 'docs/**'
    tags:
      - 'v*'  # Trigger on version tags created by the pipeline
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      target_branch:
        description: 'Branch to build from (leave empty for current branch)'
        required: false
        default: ''
        type: string
      is_test_release:
        description: 'Is this a test release? (will not create GitHub release)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  pages: write
  id-token: write

env:
  NODE_VERSION: '20'
  RUST_VERSION: '1.88.0'
  PNPM_VERSION: '10.12.1'
  # UTF-8 encoding to prevent Unicode errors on Windows
  PYTHONIOENCODING: utf-8
  PYTHONLEGACYWINDOWSFSENCODING: utf-8
  LC_ALL: C.UTF-8
  LANG: C.UTF-8

# Allow one concurrent deployment to pages per workflow run
concurrency:
  group: "pages-${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: false

jobs:
  # 🧹 Cleanup old artifacts to free storage
  cleanup:
    name: 🧹 Cleanup Old Artifacts
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: 🧹 Delete old artifacts (ULTRA AGGRESSIVE)
        uses: actions/github-script@v7
        with:
          script: |
            console.log('🧹 Starting ULTRA AGGRESSIVE artifact cleanup to free storage...');
            
            // Get all artifacts
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            console.log(`📊 Found ${artifacts.data.total_count} artifacts`);
            
            // Sort artifacts by creation date (newest first)
            const sortedArtifacts = artifacts.data.artifacts.sort((a, b) => 
              new Date(b.created_at) - new Date(a.created_at)
            );
            
            // ULTRA AGGRESSIVE CLEANUP: Keep only the SINGLE most recent artifact
            let deletedCount = 0;
            let preservedCount = 0;
            let totalSizeFreed = 0;
            
            for (let i = 0; i < sortedArtifacts.length; i++) {
              const artifact = sortedArtifacts[i];
              const sizeMB = Math.round(artifact.size_in_bytes / 1024 / 1024);
              
              if (i < 1) {
                // Keep only the SINGLE most recent artifact
                console.log(`🔒 Keeping artifact: ${artifact.name} (${sizeMB}MB) - Most recent artifact`);
                preservedCount++;
              } else {
                // Delete ALL other artifacts
                console.log(`🗑️  Deleting artifact: ${artifact.name} (${sizeMB}MB)`);
                try {
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id
                  });
                  deletedCount++;
                  totalSizeFreed += sizeMB;
                } catch (error) {
                  console.log(`⚠️  Failed to delete ${artifact.name}: ${error.message}`);
                }
              }
            }
            
            console.log(`✅ ULTRA AGGRESSIVE cleanup completed!`);
            console.log(`🗑️  Deleted ${deletedCount} artifacts`);
            console.log(`💾 Freed approximately ${totalSizeFreed}MB of storage`);
            console.log(`🔒 Preserved ${preservedCount} recent artifact`);
            console.log(`🚀 Maximum storage now available for new builds`);

  # 🏷️ Version Management
  version:
    name: 🏷️ Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          fetch-depth: 0
          lfs: true
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: 🔧 Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 📦 Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: 🏷️ Calculate new version
        id: version
        shell: bash
        run: |
          echo "🔍 Starting automatic version calculation..."
          
          # Get current version from tauri.conf.json (primary source)
          CURRENT_VERSION=$(cat desktop/src-tauri/tauri.conf.json | jq -r '.version')
          echo "📋 Current version from tauri.conf.json: $CURRENT_VERSION"
          
          # Verify consistency with package.json
          PACKAGE_VERSION=$(cat desktop/ui/package.json | jq -r '.version')
          echo "📋 Package.json version: $PACKAGE_VERSION"
          
          if [ "$CURRENT_VERSION" != "$PACKAGE_VERSION" ]; then
            echo "⚠️  Version mismatch detected!"
            echo "Using tauri.conf.json version: $CURRENT_VERSION"
          fi
          
          # Determine version bump type
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          if [ -z "$VERSION_TYPE" ]; then
            VERSION_TYPE="patch"
            echo "🎯 No version type specified, defaulting to patch"
          fi
          echo "📈 Version bump type: $VERSION_TYPE"
          
          # Check if this is a test release
          IS_TEST_RELEASE="${{ github.event.inputs.is_test_release }}"
          CURRENT_BRANCH="${{ github.event.inputs.target_branch || github.ref_name }}"
          echo "🧪 Is test release: $IS_TEST_RELEASE"
          echo "🌿 Current branch: $CURRENT_BRANCH"
          
          # Parse current version (format: x.y.z)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          echo "📊 Current version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"
          
          # Calculate new version based on type
          case "$VERSION_TYPE" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              echo "🚀 Major version bump: $MAJOR.$MINOR.$PATCH → $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              echo "✨ Minor version bump: $MAJOR.$MINOR.$PATCH → $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
            "patch"|*)
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              echo "🔧 Patch version bump: $MAJOR.$MINOR.$PATCH → $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
              ;;
          esac
          
          NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          
          # For test releases, add branch identifier to make version unique
          if [ "$IS_TEST_RELEASE" == "true" ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "refs/heads/main" ]; then
            # Clean branch name for version (remove special chars, limit length)
            CLEAN_BRANCH=$(echo "$CURRENT_BRANCH" | sed 's/refs\/heads\///' | sed 's/[^a-zA-Z0-9]/-/g' | cut -c1-20)
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH-test-$CLEAN_BRANCH"
            echo "🧪 Test release version with branch: $NEW_VERSION"
          fi
          
          NEW_TAG="v$NEW_VERSION"
          
          echo "🎯 New version: $NEW_VERSION"
          echo "🏷️ New tag: $NEW_TAG"
          
          # Enhanced tag conflict detection and resolution
          echo "🔍 Checking for tag conflicts..."
          
          # Check local tags
          if git tag -l | grep -q "^$NEW_TAG$"; then
            echo "⚠️  Local tag $NEW_TAG already exists!"
            LOCAL_TAG_COMMIT=$(git rev-parse "$NEW_TAG")
            echo "📍 Local tag points to commit: $LOCAL_TAG_COMMIT"
            echo "🔄 Force incrementing patch version to resolve conflict..."
            NEW_PATCH=$((NEW_PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            NEW_TAG="v$NEW_VERSION"
            echo "🎯 Conflict resolved - New version: $NEW_VERSION"
          fi
          
          # Check remote tags
          if git ls-remote --tags origin | grep -q "refs/tags/$NEW_TAG$"; then
            echo "⚠️  Remote tag $NEW_TAG already exists!"
            REMOTE_TAG_COMMIT=$(git ls-remote --tags origin | grep "refs/tags/$NEW_TAG$" | cut -f1)
            echo "📍 Remote tag points to commit: $REMOTE_TAG_COMMIT"
            echo "🔄 Force incrementing patch version to resolve conflict..."
            NEW_PATCH=$((NEW_PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            NEW_TAG="v$NEW_VERSION"
            echo "🎯 Conflict resolved - New version: $NEW_VERSION"
          fi
          
          # Double-check that the final tag doesn't exist
          if git tag -l | grep -q "^$NEW_TAG$" || git ls-remote --tags origin | grep -q "refs/tags/$NEW_TAG$"; then
            echo "❌ Even after conflict resolution, tag $NEW_TAG still exists!"
            echo "🔄 Using build number for uniqueness (MSI-compatible)..."
            # Use GitHub run number (always < 65535) for MSI compatibility
            BUILD_NUMBER="${{ github.run_number }}"
            # If somehow run number is > 65535, use modulo to keep it within bounds
            if [ "$BUILD_NUMBER" -gt 65535 ]; then
              BUILD_NUMBER=$((BUILD_NUMBER % 65535))
            fi
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH-$BUILD_NUMBER"
            NEW_TAG="v$NEW_VERSION"
            echo "🎯 Emergency version: $NEW_VERSION (MSI-compatible)"
          fi
          
          # Validate MSI compatibility
          echo "🔍 Validating MSI compatibility..."
          if [[ "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[0-9]+)?$ ]]; then
            echo "✅ Version format is MSI-compatible: $NEW_VERSION"
            # If there's a pre-release identifier, validate it's within bounds
            if [[ "$NEW_VERSION" =~ -([0-9]+)$ ]]; then
              PRE_RELEASE_NUM="${BASH_REMATCH[1]}"
              if [ "$PRE_RELEASE_NUM" -gt 65535 ]; then
                echo "❌ Pre-release identifier $PRE_RELEASE_NUM exceeds MSI limit of 65535"
                exit 1
              fi
              echo "✅ Pre-release identifier $PRE_RELEASE_NUM is within MSI limits"
            fi
          else
            echo "❌ Version format is not MSI-compatible: $NEW_VERSION"
            echo "MSI requires format: major.minor.patch[-numeric] where numeric ≤ 65535"
            exit 1
          fi
          
          # Update tauri.conf.json
          echo "📝 Updating tauri.conf.json..."
          jq --arg version "$NEW_VERSION" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "✅ Updated tauri.conf.json to version $NEW_VERSION"
          
          # Update package.json
          echo "📝 Updating package.json..."
          jq --arg version "$NEW_VERSION" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "✅ Updated package.json to version $NEW_VERSION"
          
          # Generate changelog
          echo "📋 Generating changelog..."
          
          # Get commit messages since last tag
          LAST_TAG=$(git tag -l --sort=-version:refname | head -1)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="HEAD~10"  # If no tags, get last 10 commits
          fi
          
          # Get simplified commit messages (first line only, safe for heredoc)
          COMMITS=$(git log --oneline --no-merges "$LAST_TAG"..HEAD --pretty=format:"- %s" | head -5 | cut -c1-60 || echo "- Recent improvements and bug fixes")
          
          # Generate changelog based on release type
          if [ "$IS_TEST_RELEASE" == "true" ]; then
            CHANGELOG=$(cat << EOF
          ## 🧪 GeneKnow Test Build $NEW_VERSION
          
          ### 📋 Test Build Details
          - **Build Type**: Test Release (No GitHub Release)
          - **Source Branch**: $CURRENT_BRANCH
          - **Build Purpose**: Testing and validation
          - Cross-platform builds (macOS, Windows, Linux)
          
          ### 🔄 Changes Since Last Release
          $COMMITS
          
          ### 🔨 Technical Details
          - **Version**: $NEW_VERSION
          - **Version Type**: $VERSION_TYPE
          - **Previous Version**: $CURRENT_VERSION
          - **Source Branch**: $CURRENT_BRANCH
          - **Tauri**: 2.6.2
          - **React**: 19.1.0
          - **TypeScript**: 5.8.3
          
          ### 📝 Note
          This is a test build. Artifacts are available for download but no GitHub release will be created.
          EOF
          )
          else
            CHANGELOG=$(cat << EOF
          ## 🧬 GeneKnow Release $NEW_VERSION
          
          ### 📋 What's New
          - Automated release build for desktop application
          - Cross-platform builds (macOS, Windows, Linux)
          - Privacy-first genomic risk assessment platform
          
          ### 🔄 Changes Since Last Release
          $COMMITS
          
          ### 🔨 Technical Details
          - **Version**: $NEW_VERSION
          - **Version Type**: $VERSION_TYPE
          - **Previous Version**: $CURRENT_VERSION
          - **Tauri**: 2.6.2
          - **React**: 19.1.0
          - **TypeScript**: 5.8.3
          
          ### 📦 Download
          Choose the appropriate installer for your platform below.
          EOF
          )
          fi
          
          # Debug changelog content
          echo "📋 Changelog generated successfully (${#CHANGELOG} characters)"
          
          # Set outputs with safer heredoc handling
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          {
            echo "changelog<<CHANGELOG_EOF"
            echo "$CHANGELOG"
            echo "CHANGELOG_EOF"
          } >> $GITHUB_OUTPUT
          
          echo "✅ Version calculation completed successfully!"

      - name: 🧹 Clean up existing release if exists
        run: |
          echo "🧹 Checking for existing release..."
          if gh release view ${{ steps.version.outputs.tag }} >/dev/null 2>&1; then
            echo "⚠️  Release ${{ steps.version.outputs.tag }} already exists. Deleting..."
            gh release delete ${{ steps.version.outputs.tag }} --yes
            echo "✅ Existing release deleted"
          else
            echo "✅ No existing release found"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 📤 Create and push git tag
        # Only create and push tags for production releases, not test releases
        if: github.event.inputs.is_test_release != 'true'
        run: |
          echo "📤 Creating and pushing git tag..."
          
          # Enhanced tag conflict detection and resolution
          TAG_NAME="${{ steps.version.outputs.tag }}"
          
          # Check for local tag conflicts
          if git tag -l | grep -q "^$TAG_NAME$"; then
            echo "🧹 Found existing local tag: $TAG_NAME"
            LOCAL_TAG_COMMIT=$(git rev-parse "$TAG_NAME")
            echo "📍 Local tag points to commit: $LOCAL_TAG_COMMIT"
            
            # Delete local tag
            git tag -d "$TAG_NAME"
            echo "✅ Deleted local tag: $TAG_NAME"
          fi
          
          # Check for remote tag conflicts
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "🧹 Found existing remote tag: $TAG_NAME"
            REMOTE_TAG_COMMIT=$(git ls-remote --tags origin | grep "refs/tags/$TAG_NAME$" | cut -f1)
            echo "📍 Remote tag points to commit: $REMOTE_TAG_COMMIT"
            
            # Delete remote tag with error handling
            if git push origin ":refs/tags/$TAG_NAME" 2>/dev/null; then
              echo "✅ Deleted remote tag: $TAG_NAME"
            else
              echo "⚠️  Failed to delete remote tag, continuing anyway..."
            fi
          fi
          
          # Wait a moment for tag deletion to propagate
          sleep 2
          
          # Create and push new tag with retry logic
          echo "📤 Creating new tag: $TAG_NAME"
          git tag "$TAG_NAME"
          
          # Push with retry logic
          for i in {1..3}; do
            if git push origin "$TAG_NAME"; then
              echo "✅ Successfully pushed tag: $TAG_NAME (attempt $i)"
              break
            else
              echo "⚠️  Failed to push tag (attempt $i), retrying in 5 seconds..."
              sleep 5
              if [ $i -eq 3 ]; then
                echo "❌ Failed to push tag after 3 attempts"
                exit 1
              fi
            fi
          done
          
          # Verify tag was pushed correctly
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "✅ Tag successfully created and pushed: $TAG_NAME"
          else
            echo "❌ Tag verification failed - tag not found on remote"
            exit 1
          fi
          
          echo "ℹ️  Note: Version files are updated locally for build process only"
          echo "ℹ️  Use ./scripts/bump-version.sh to update version files in repository"

      - name: 🧪 Test release info
        # Only show this message for test releases
        if: github.event.inputs.is_test_release == 'true'
        run: |
          echo "🧪 This is a test release - no git tag will be created"
          echo "📝 Test build will generate artifacts but not create a GitHub release"
          echo "🎯 Version: ${{ steps.version.outputs.version }}"
          echo "🏷️ Tag (for reference): ${{ steps.version.outputs.tag }}"
          echo "🌿 Branch: ${{ github.event.inputs.target_branch || github.ref_name }}"



  # 🧪 Validation & Testing
  validate:
    name: 🧪 Validation & Testing
    needs: [version]
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          lfs: true

      - name: 🔄 Update version files for validation
        shell: bash
        run: |
          echo "🔄 Updating version files to ${{ needs.version.outputs.version }}..."
          
          # Update tauri.conf.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "✅ Updated tauri.conf.json"
          
          # Update package.json  
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "✅ Updated package.json"
          
          echo "🎯 Version files updated for validation process"

      - name: 🔧 Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 📦 Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: 🔍 Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: 🚀 Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: 📦 Install frontend dependencies
        working-directory: desktop/ui
        run: |
          echo "📦 Installing dependencies for validation..."
          pnpm install --frozen-lockfile
          echo "✅ Dependencies installed"

      - name: 🔍 Run validation checks
        working-directory: desktop/ui
        run: |
          echo "🔍 Running ESLint..."
          pnpm lint
          echo "✅ ESLint passed"
          
          echo "🔍 Running TypeScript check..."
          pnpm exec tsc --noEmit
          echo "✅ TypeScript check passed"
          
          echo "🔨 Building frontend..."
          pnpm build
          echo "✅ Frontend build successful"

  # 🔨 Build Multi-Platform Release
  build:
    name: 🔨 Build Release
    needs: [cleanup, version]
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            rust-target: x86_64-unknown-linux-gnu
            name: 'Linux x64'
            emoji: '🐧'
            build-key: 'linux'
          - os: windows-latest
            rust-target: x86_64-pc-windows-msvc
            name: 'Windows x64'
            emoji: '🪟'
            build-key: 'windows'
          - os: macos-latest
            rust-target: x86_64-apple-darwin
            name: 'macOS x64'
            emoji: '🍎'
            build-key: 'macos'
          - os: macos-latest
            rust-target: aarch64-apple-darwin
            name: 'macOS ARM64'
            emoji: '🍏'
            build-key: 'macos-arm'
    runs-on: ${{ matrix.os }}
    steps:

      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          lfs: true

      - name: 🔄 Update version files for build
        shell: bash
        run: |
          echo "🔄 Updating version files to ${{ needs.version.outputs.version }}..."
          
          # Update tauri.conf.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/src-tauri/tauri.conf.json > desktop/src-tauri/tauri.conf.json.tmp
          mv desktop/src-tauri/tauri.conf.json.tmp desktop/src-tauri/tauri.conf.json
          echo "✅ Updated tauri.conf.json"
          
          # Update package.json
          jq --arg version "${{ needs.version.outputs.version }}" '.version = $version' desktop/ui/package.json > desktop/ui/package.json.tmp
          mv desktop/ui/package.json.tmp desktop/ui/package.json
          echo "✅ Updated package.json"
          
          echo "🎯 Version files updated for build process"

      - name: 🔧 Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 📦 Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: 🦀 Setup Rust ${{ env.RUST_VERSION }}
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: ${{ matrix.rust-target }}

      - name: 🚀 Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            desktop/src-tauri -> target

      - name: 🔍 Cache Tauri CLI
        uses: actions/cache@v4
        id: tauri-cli-cache
        with:
          path: |
            ~/.cargo/bin/cargo-tauri
            ~/.cargo/bin/cargo-tauri.exe
          key: ${{ runner.os }}-tauri-cli-${{ env.RUST_VERSION }}
          restore-keys: |
            ${{ runner.os }}-tauri-cli-

      - name: 📦 Install Tauri CLI
        if: steps.tauri-cli-cache.outputs.cache-hit != 'true'
        run: |
          echo "📦 Installing Tauri CLI..."
          cargo install tauri-cli --locked
          echo "✅ Tauri CLI installed successfully"

      - name: 🔍 Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: 🚀 Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: 🔧 Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          echo "🔧 Installing Linux system dependencies..."
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev librsvg2-dev
          echo "✅ Linux dependencies installed"

      - name: 🔧 Install system dependencies (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          echo "🔧 Windows system dependencies are handled by Tauri automatically"
          echo "✅ Windows dependencies ready"

      - name: 🔧 Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "🔧 macOS system dependencies are handled by Tauri automatically"
          echo "✅ macOS dependencies ready"

      - name: 📦 Install frontend dependencies
        working-directory: desktop/ui
        run: |
          echo "📦 Installing frontend dependencies..."
          pnpm install --frozen-lockfile
          echo "✅ Frontend dependencies installed"

      - name: 🔨 Build frontend
        working-directory: desktop/ui
        run: |
          echo "🔨 Building frontend for release..."
          pnpm build
          echo "✅ Frontend build completed"

      - name: 🐍 Bundle Python runtime and dependencies
        working-directory: desktop
        shell: bash
        run: |
          echo "🐍 Bundling Python runtime for ${{ matrix.name }}..."
          echo "📍 Current working directory: $(pwd)"
          echo "📂 Contents of desktop directory:"
          ls -la
          
          # Make script executable
          chmod +x scripts/bundle-python-optimized.sh
          
          # Run the optimized bundling script (no TensorFlow, 364MB instead of 1.9GB)
          echo "🚀 Running bundling script..."
          if ./scripts/bundle-python-optimized.sh; then
            echo "✅ Bundle script executed successfully"
          else
            echo "❌ Bundle script failed with exit code $?"
            exit 1
          fi
          
          # Verify bundled resources were created
          echo "🔍 Verifying bundled resources were created..."
          if [ -d "bundled_resources" ]; then
            echo "✅ bundled_resources directory exists"
            echo "📊 Bundle size: $(du -sh bundled_resources | cut -f1)"
            echo "📂 Bundle contents:"
            ls -la bundled_resources/
            
            # Check for critical files
            if [ -f "bundled_resources/start_api_server.sh" ]; then
              echo "✅ start_api_server.sh found"
            else
              echo "❌ start_api_server.sh MISSING - this will cause startup failures"
              exit 1
            fi
            
            if [ -d "bundled_resources/python_runtime" ]; then
              echo "✅ python_runtime directory found"
            else
              echo "❌ python_runtime directory MISSING"
              exit 1
            fi
            
            if [ -d "bundled_resources/geneknow_pipeline" ]; then
              echo "✅ geneknow_pipeline directory found"
            else
              echo "❌ geneknow_pipeline directory MISSING"
              exit 1
            fi
            
          else
            echo "❌ bundled_resources directory NOT FOUND"
            echo "📂 Current directory contents:"
            ls -la
            exit 1
          fi
          
          echo "✅ Python runtime bundled successfully"

      - name: 🔨 Build Tauri Release
        working-directory: desktop/src-tauri
        shell: bash
        run: |
          echo "${{ matrix.emoji }} Building Tauri release for ${{ matrix.name }}..."
          echo "🎯 Target: ${{ matrix.rust-target }}"
          echo "📦 Version: ${{ needs.version.outputs.version }}"
          
          # Add debugging for macOS app bundle issues
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            echo "🍎 macOS Environment Debug Info:"
            echo "   Disk space: $(df -h . | tail -1)"
            echo "   Available memory: $(vm_stat | grep free)"
            echo "   Xcode tools: $(xcode-select -p 2>/dev/null || echo 'Not found')"
            echo "   Bundle dir size: $(du -sh ../bundled_resources 2>/dev/null || echo 'Not found')"
          fi
          
          # Pre-build verification of bundled resources
          echo "🔍 Pre-build verification of bundled resources..."
          echo "📍 Current working directory: $(pwd)"
          echo "📂 Contents of src-tauri directory:"
          ls -la
          
          if [ -d "../bundled_resources" ]; then
            echo "✅ bundled_resources directory found relative to src-tauri"
            echo "📊 Bundle size: $(du -sh ../bundled_resources | cut -f1)"
            echo "📂 Critical files check:"
            
            if [ -f "../bundled_resources/start_api_server.sh" ]; then
              echo "   ✅ start_api_server.sh found"
            else
              echo "   ❌ start_api_server.sh MISSING"
              exit 1
            fi
            
            if [ -d "../bundled_resources/python_runtime" ]; then
              echo "   ✅ python_runtime directory found"
            else
              echo "   ❌ python_runtime directory MISSING"
              exit 1
            fi
            
            if [ -d "../bundled_resources/geneknow_pipeline" ]; then
              echo "   ✅ geneknow_pipeline directory found"
            else
              echo "   ❌ geneknow_pipeline directory MISSING"
              exit 1
            fi
            
            echo "🔧 Verifying tauri.conf.json resources configuration..."
            if grep -A5 '"resources"' tauri.conf.json | grep -q '"../bundled_resources"'; then
              echo "   ✅ tauri.conf.json correctly configured to include bundled_resources"
            else
              echo "   ❌ tauri.conf.json NOT correctly configured"
              echo "   📄 Current resources configuration:"
              grep -A3 -B1 '"resources"' tauri.conf.json || echo "   No resources section found"
              exit 1
            fi
            
          else
            echo "❌ bundled_resources directory NOT FOUND relative to src-tauri"
            echo "📂 Contents of parent directory:"
            ls -la ..
            exit 1
          fi
          
          # Set debug logging for Tauri
          export RUST_LOG=debug
          export RUST_BACKTRACE=1
          
          cargo tauri build --target ${{ matrix.rust-target }} --verbose
          
          echo "✅ Tauri release build completed for ${{ matrix.name }}"

      - name: 🗜️ Package macOS .app as ZIP
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "🗜️ Creating ZIP archive for macOS .app bundle..."
          
          # Find the .app bundle
          APP_PATH=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/macos/ -name "*.app" -type d | head -1)
          
          if [ -n "$APP_PATH" ]; then
            echo "✅ Found app bundle: $APP_PATH"
            APP_NAME=$(basename "$APP_PATH")
            ZIP_NAME="${APP_NAME%.app}-${{ needs.version.outputs.version }}-${{ matrix.rust-target }}.zip"
            
            # Create ZIP in the bundle directory
            cd "$(dirname "$APP_PATH")"
            echo "📦 Creating ZIP: $ZIP_NAME"
            
            # Use ditto to preserve macOS attributes and bundle structure
            ditto -c -k --sequesterRsrc --keepParent "$APP_NAME" "$ZIP_NAME"
            
            if [ -f "$ZIP_NAME" ]; then
              echo "✅ ZIP created successfully"
              echo "📊 ZIP size: $(du -sh "$ZIP_NAME" | cut -f1)"
              
              # Verify ZIP contents
              echo "🔍 Verifying ZIP contents..."
              unzip -l "$ZIP_NAME" | grep -E "(start_api_server|python_runtime|geneknow_pipeline)" | head -10
            else
              echo "❌ Failed to create ZIP"
              exit 1
            fi
          else
            echo "❌ Could not find .app bundle"
            echo "📂 Looking in:"
            find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -type d -name "*.app" 2>/dev/null || echo "No .app bundles found"
            exit 1
          fi

      - name: 🔍 Verify bundled resources in build artifacts
        shell: bash
        run: |
          echo "🔍 Verifying bundled resources are included in build artifacts..."
          
          # Find the built application
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            # macOS ZIP verification
            ZIP_PATH=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/macos/ -name "*.zip" | head -1)
            if [ -n "$ZIP_PATH" ]; then
              echo "🍎 Found macOS ZIP: $ZIP_PATH"
              echo "📊 ZIP size: $(du -sh "$ZIP_PATH" | cut -f1)"
              
              # Create temporary directory and extract ZIP to verify contents
              TEMP_EXTRACT_DIR=$(mktemp -d)
              echo "📦 Extracting ZIP to verify bundled resources..."
              
              if unzip -q "$ZIP_PATH" -d "$TEMP_EXTRACT_DIR"; then
                echo "✅ ZIP extracted successfully"
                
                # Find the app bundle inside the extracted ZIP
                APP_PATH=$(find "$TEMP_EXTRACT_DIR" -name "*.app" -type d | head -1)
                if [ -n "$APP_PATH" ]; then
                  echo "✅ Found app bundle in ZIP: $APP_PATH"
                  
                  # Check for bundled resources in the app bundle
                  RESOURCES_PATH="$APP_PATH/Contents/Resources"
                  if [ -d "$RESOURCES_PATH" ]; then
                    echo "✅ Resources directory found in app bundle"
                    
                    # Check for our bundled resources
                    BUNDLED_PATH="$RESOURCES_PATH/_up_/bundled_resources"
                    if [ -d "$BUNDLED_PATH" ]; then
                      echo "✅ bundled_resources found in app bundle at: $BUNDLED_PATH"
                      echo "📊 Bundle size in app: $(du -sh "$BUNDLED_PATH" | cut -f1)"
                      
                      # Check critical files
                      if [ -f "$BUNDLED_PATH/start_api_server.sh" ]; then
                        echo "   ✅ start_api_server.sh found in app bundle"
                      else
                        echo "   ❌ start_api_server.sh MISSING from app bundle"
                        rm -rf "$TEMP_EXTRACT_DIR"
                        exit 1
                      fi
                      
                      if [ -d "$BUNDLED_PATH/python_runtime" ]; then
                        echo "   ✅ python_runtime found in app bundle"
                      else
                        echo "   ❌ python_runtime MISSING from app bundle"
                        rm -rf "$TEMP_EXTRACT_DIR"
                        exit 1
                      fi
                      
                      if [ -d "$BUNDLED_PATH/geneknow_pipeline" ]; then
                        echo "   ✅ geneknow_pipeline found in app bundle"
                      else
                        echo "   ❌ geneknow_pipeline MISSING from app bundle"
                        rm -rf "$TEMP_EXTRACT_DIR"
                        exit 1
                      fi
                      
                    else
                      echo "❌ bundled_resources NOT found in app bundle"
                      echo "📂 _up_ directory contents:"
                      ls -la "$RESOURCES_PATH/_up_/" 2>/dev/null || echo "   _up_ directory not found"
                      rm -rf "$TEMP_EXTRACT_DIR"
                      exit 1
                    fi
                  else
                    echo "❌ Resources directory not found in app bundle"
                    rm -rf "$TEMP_EXTRACT_DIR"
                    exit 1
                  fi
                else
                  echo "❌ Could not find app bundle in ZIP"
                  rm -rf "$TEMP_EXTRACT_DIR"
                  exit 1
                fi
                
                # Clean up
                rm -rf "$TEMP_EXTRACT_DIR"
                
              else
                echo "❌ Failed to extract ZIP for verification"
                exit 1
              fi
              
            else
              echo "❌ Could not find macOS ZIP"
              echo "📂 Looking for ZIP in:"
              find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.zip" 2>/dev/null || echo "   No ZIP files found"
              exit 1
            fi
          elif [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            # Linux AppImage or deb verification
            echo "🐧 Checking Linux build artifacts..."
            
            # Find .deb package
            DEB_PATH=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/deb/ -name "*.deb" -type f 2>/dev/null | head -1)
            if [ -n "$DEB_PATH" ]; then
              echo "✅ Found Linux DEB package: $DEB_PATH"
              echo "📊 DEB size: $(du -sh "$DEB_PATH" | cut -f1)"
              
              # Extract and verify DEB contents
              TEMP_EXTRACT_DIR=$(mktemp -d)
              echo "📦 Extracting DEB to verify bundled resources..."
              
              if dpkg-deb --extract "$DEB_PATH" "$TEMP_EXTRACT_DIR" 2>/dev/null; then
                echo "✅ DEB extracted successfully"
                
                # Look for bundled resources in the extracted package
                BUNDLED_PATH_CANDIDATES=(
                  "$TEMP_EXTRACT_DIR/usr/bin/bundled_resources"
                  "$TEMP_EXTRACT_DIR/usr/share/*/bundled_resources"
                  "$TEMP_EXTRACT_DIR/opt/*/bundled_resources"
                )
                
                BUNDLED_FOUND=false
                for path in "${BUNDLED_PATH_CANDIDATES[@]}"; do
                  if [ -d "$path" ]; then
                    echo "✅ bundled_resources found in DEB at: $path"
                    echo "📊 Bundle size in DEB: $(du -sh "$path" | cut -f1)"
                    
                    # Check for critical files
                    if [ -f "$path/start_api_server.sh" ]; then
                      echo "   ✅ start_api_server.sh found in DEB"
                    else
                      echo "   ⚠️  start_api_server.sh not found in DEB"
                    fi
                    
                    if [ -d "$path/python_runtime" ]; then
                      echo "   ✅ python_runtime found in DEB"
                    else
                      echo "   ⚠️  python_runtime not found in DEB"
                    fi
                    
                    if [ -d "$path/geneknow_pipeline" ]; then
                      echo "   ✅ geneknow_pipeline found in DEB"
                    else
                      echo "   ⚠️  geneknow_pipeline not found in DEB"
                    fi
                    
                    BUNDLED_FOUND=true
                    break
                  fi
                done
                
                if [ "$BUNDLED_FOUND" = false ]; then
                  echo "⚠️  bundled_resources not found in expected locations"
                  echo "📂 DEB structure preview:"
                  find "$TEMP_EXTRACT_DIR" -type d -name "*bundled*" 2>/dev/null || echo "   No bundled directories found"
                  find "$TEMP_EXTRACT_DIR" -type f -name "start_api_server.sh" 2>/dev/null || echo "   No start_api_server.sh found"
                fi
                
                # Clean up
                rm -rf "$TEMP_EXTRACT_DIR"
              else
                echo "⚠️  Failed to extract DEB for verification"
              fi
            else
              echo "⚠️  Could not find Linux DEB package"
              echo "📂 Looking for DEB in:"
              find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.deb" -type f 2>/dev/null || echo "   No DEB files found"
            fi
            
            # Show first few build artifacts safely (avoiding broken pipe)
            echo "📂 First few build artifacts:"
            find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -type f 2>/dev/null | head -5 || echo "   No artifacts found"
            
          elif [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # Windows MSI/EXE verification
            echo "🪟 Checking Windows build artifacts..."
            
            # Find MSI installer
            MSI_PATH=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/msi/ -name "*.msi" -type f 2>/dev/null | head -1)
            if [ -n "$MSI_PATH" ]; then
              echo "✅ Found Windows MSI installer: $MSI_PATH"
              echo "📊 MSI size: $(du -sh "$MSI_PATH" | cut -f1)"
            else
              echo "⚠️  Could not find Windows MSI installer"
            fi
            
            # Find EXE installer
            EXE_PATH=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/nsis/ -name "*.exe" -type f 2>/dev/null | head -1)
            if [ -n "$EXE_PATH" ]; then
              echo "✅ Found Windows EXE installer: $EXE_PATH"
              echo "📊 EXE size: $(du -sh "$EXE_PATH" | cut -f1)"
            else
              echo "⚠️  Could not find Windows EXE installer"
            fi
            
            # Show first few build artifacts safely (avoiding broken pipe)
            echo "📂 First few build artifacts:"
            find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -type f 2>/dev/null | head -5 || echo "   No artifacts found"
          fi
          
          echo "✅ Build artifact verification completed"

      - name: 📂 Locate build artifacts (Unix)
        id: artifacts-unix
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          echo "📂 Locating build artifacts..."
          echo "🔍 Searching in desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/"
          
          # Find all bundle files safely (avoiding broken pipe)
          echo "📦 Build artifacts found:"
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -type f -name "*" 2>/dev/null | sort || echo "   No artifacts found"
          
          # Count artifacts by type
          echo "📊 Artifact summary:"
          DMG_COUNT=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.dmg" -type f 2>/dev/null | wc -l)
          DEB_COUNT=$(find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.deb" -type f 2>/dev/null | wc -l)
          echo "   🍎 DMG files: $DMG_COUNT"
          echo "   🐧 DEB files: $DEB_COUNT"
          
          echo "✅ Build artifacts located"

      - name: 📂 Locate build artifacts (Windows)
        id: artifacts-windows
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "📂 Locating build artifacts..."
          echo "🔍 Searching in desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/"
          
          # Find all bundle files using PowerShell
          Get-ChildItem -Path "desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/" -Recurse -File | Sort-Object FullName | ForEach-Object { $_.FullName }
          
          echo "✅ Build artifacts located"

      - name: 📤 Upload build artifacts
        # Upload artifacts for release builds (main branch pushes, tag pushes, and workflow dispatch)
        if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-${{ needs.version.outputs.version }}
          path: |
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.zip
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.msi
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.deb
            desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/*/*.exe
          if-no-files-found: error
          retention-days: 1
          compression-level: 9

      - name: 📊 Build summary
        shell: bash
        run: |
          echo "📊 Build completed successfully for ${{ matrix.name }}"
          echo "🎯 Version: ${{ needs.version.outputs.version }}"
          echo "🏷️ Tag: ${{ needs.version.outputs.tag }}"
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == refs/tags/* || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "📦 Artifacts uploaded to GitHub Actions (release build)"
            echo "🏪 Artifacts will be permanently stored in GitHub Release"
          else
            echo "📦 Artifacts built but not uploaded (branch push - saves storage)"
            echo "🔍 Build validation completed without storage usage"
          fi

      - name: 🏪 Store artifacts for release (Direct Storage)
        # For release builds, also prepare artifacts for direct release upload
        if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          echo "🏪 Preparing artifacts for direct release storage..."
          mkdir -p ./release-ready
          
          # Copy all installer files to release-ready directory
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.zip" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.msi" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.deb" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          find desktop/src-tauri/target/${{ matrix.rust-target }}/release/bundle/ -name "*.exe" -exec cp {} ./release-ready/ \; 2>/dev/null || true
          
          echo "✅ Artifacts prepared for release storage:"
          ls -la ./release-ready/ || echo "No artifacts found"

      - name: 📤 Upload release-ready artifacts
        # Upload prepared artifacts for the release job
        if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: release-ready-${{ matrix.name }}-${{ needs.version.outputs.version }}
          path: ./release-ready/*
          if-no-files-found: warn
          retention-days: 1
          compression-level: 9

  # 🚀 Create GitHub Release
  release:
    name: 🚀 Create GitHub Release
    needs: [version, build]
    runs-on: ubuntu-latest
    # Create releases for main branch pushes, tag pushes, and workflow dispatch events (but not for test releases)
    if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch') && github.event.inputs.is_test_release != 'true'
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          lfs: true

      - name: 📥 Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: "release-ready-*-${{ needs.version.outputs.version }}"
          merge-multiple: true

      - name: 📂 List artifacts
        shell: bash
        run: |
          echo "📂 Downloaded artifacts:"
          find ./artifacts -type f -name "*" | sort

      - name: 🗂️ Organize artifacts by platform
        shell: bash
        run: |
          echo "🗂️ Organizing installer files for release..."
          mkdir -p ./release-assets
          
          # Copy all installer files from artifacts
          find ./artifacts -name "*.zip" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.msi" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.deb" -exec cp {} ./release-assets/ \;
          find ./artifacts -name "*.exe" -exec cp {} ./release-assets/ \;
          
          echo "✅ Organized installer files:"
          ls -la ./release-assets/
          
          # Verify we have installers for all platforms
          echo "📊 Platform coverage:"
          echo "🍎 macOS: $(ls ./release-assets/*.zip 2>/dev/null | wc -l) ZIP archives"
          echo "🪟 Windows: $(ls ./release-assets/*.msi 2>/dev/null | wc -l) MSI + $(ls ./release-assets/*.exe 2>/dev/null | wc -l) EXE"
          echo "🐧 Linux: $(ls ./release-assets/*.deb 2>/dev/null | wc -l) DEB packages"

      - name: 🚀 Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: 🧬 GeneKnow ${{ needs.version.outputs.version }}
          body: ${{ needs.version.outputs.changelog }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            ./release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 📋 Release summary
        run: |
          echo "# 🧬 GeneKnow Release ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🎉 Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 📦 Available Downloads" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- 🐧 **Linux**: .deb packages" >> $GITHUB_STEP_SUMMARY
          echo "- 🪟 **Windows**: .msi and .exe installers" >> $GITHUB_STEP_SUMMARY
          echo "- 🍎 **macOS**: .zip archive (Universal Binary)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🔗 Links" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [📄 Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.version.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
          echo "- [📥 Download Page](https://github.com/${{ github.repository }}/releases/latest)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "🧬 **GeneKnow** - Privacy-First Genomic Risk Assessment Platform" >> $GITHUB_STEP_SUMMARY 
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🌐 Website Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The download website will be automatically updated with this release." >> $GITHUB_STEP_SUMMARY
          echo "Visit the website to download the latest version." >> $GITHUB_STEP_SUMMARY

  # 🧪 Test Build Summary (for test releases)
  test-summary:
    name: 🧪 Test Build Summary
    needs: [version, build]
    runs-on: ubuntu-latest
    # Only run for test releases
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.is_test_release == 'true'
    steps:
      - name: 📥 Download all artifacts  
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: "release-ready-*-${{ needs.version.outputs.version }}"
          merge-multiple: true

      - name: 📊 Test build summary
        run: |
          echo "# 🧪 GeneKnow Test Build ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ✅ Test Build Completed Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.event.inputs.target_branch || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type:** Test Release (No GitHub Release Created)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 📦 Build Artifacts Generated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following platforms were successfully built:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Count artifacts by platform
          if ls ./artifacts/*.zip 1> /dev/null 2>&1; then
            echo "- 🍎 **macOS**: $(ls ./artifacts/*.zip | wc -l) ZIP archive(s)" >> $GITHUB_STEP_SUMMARY
          fi
          if ls ./artifacts/*.msi 1> /dev/null 2>&1; then
            echo "- 🪟 **Windows MSI**: $(ls ./artifacts/*.msi | wc -l) installer(s)" >> $GITHUB_STEP_SUMMARY
          fi
          if ls ./artifacts/*.exe 1> /dev/null 2>&1; then
            echo "- 🪟 **Windows EXE**: $(ls ./artifacts/*.exe | wc -l) installer(s)" >> $GITHUB_STEP_SUMMARY
          fi
          if ls ./artifacts/*.deb 1> /dev/null 2>&1; then
            echo "- 🐧 **Linux DEB**: $(ls ./artifacts/*.deb | wc -l) package(s)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 📝 Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Download artifacts from this workflow run to test locally" >> $GITHUB_STEP_SUMMARY
          echo "- If testing is successful, merge to main branch for production release" >> $GITHUB_STEP_SUMMARY
          echo "- Or run workflow again with 'Is test release?' unchecked to create GitHub release" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "🧬 **GeneKnow Test Build** - No release created, artifacts available for download" >> $GITHUB_STEP_SUMMARY

  # 🌐 Deploy Website (for production releases only)
  deploy-website:
    name: 🌐 Deploy Download Website
    needs: [version, release]
    runs-on: ubuntu-latest
    # Only deploy website for production releases, not test releases
    if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch') && github.event.inputs.is_test_release != 'true'
    concurrency:
      group: "pages-deploy-${{ github.ref }}"
      cancel-in-progress: false
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          lfs: true

      - name: ⏳ Wait for release propagation
        run: |
          echo "⏳ Waiting for GitHub release to fully propagate..."
          sleep 30
          echo "✅ Proceeding with website deployment"

      - name: 🔧 Setup Pages
        uses: actions/configure-pages@v4

      - name: 📝 Update website with latest release info
        run: |
          echo "📝 Updating website with release information..."
          echo "🎯 Version: ${{ needs.version.outputs.version }}"
          echo "🏷️ Tag: ${{ needs.version.outputs.tag }}"
          
          # Create build directory
          mkdir -p _site
          cp -r download_website/* _site/
          
          # Update repository configuration in JavaScript
          sed -i "s/const REPO_OWNER = 'astrogirlnim'/const REPO_OWNER = '${{ github.repository_owner }}'/g" _site/assets/js/releases.js
          sed -i "s/const REPO_NAME = 'GeneKnow'/const REPO_NAME = '${{ github.event.repository.name }}'/g" _site/assets/js/releases.js
          
          # Update version in mock data to match the actual release
          sed -i "s/tag_name: 'v1\.2\.3'/tag_name: '${{ needs.version.outputs.tag }}'/g" _site/assets/js/releases.js
          sed -i "s/GeneKnow v1\.2\.3/GeneKnow ${{ needs.version.outputs.version }}/g" _site/assets/js/releases.js
          
          # Update download URLs to match actual release
          sed -i "s/v1\.2\.3/${{ needs.version.outputs.version }}/g" _site/assets/js/releases.js
          
          # Add cache-busting timestamp to ensure immediate updates
          TIMESTAMP=$(date +%s)
          sed -i "s/setTimeout(() => {/setTimeout(() => { \/\/ Updated: $TIMESTAMP/g" _site/assets/js/releases.js
          
          # Update the published date to current time for immediate releases
          CURRENT_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          sed -i "s/published_at: new Date().toISOString()/published_at: '$CURRENT_DATE'/g" _site/assets/js/releases.js
          
          echo "✅ Website updated with release ${{ needs.version.outputs.version }}"
          echo "🕐 Cache-busting timestamp: $TIMESTAMP"
          echo "📅 Release date: $CURRENT_DATE"

      - name: 🚀 Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: _site

      - name: 🌐 Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: 🔍 Verify website deployment
        run: |
          echo "🔍 Verifying website deployment..."
          WEBSITE_URL="${{ steps.deployment.outputs.page_url }}"
          
          # Wait a moment for deployment to propagate
          sleep 10
          
          # Check if website is accessible
          if curl -f -s "$WEBSITE_URL" > /dev/null; then
            echo "✅ Website is accessible at: $WEBSITE_URL"
          else
            echo "⚠️  Website may not be immediately accessible (DNS propagation)"
          fi
          
          # Check if releases.js contains the new version
          if curl -f -s "${WEBSITE_URL}assets/js/releases.js" | grep -q "${{ needs.version.outputs.tag }}"; then
            echo "✅ Website contains latest release information"
          else
            echo "⚠️  Release information may still be propagating"
          fi
          
          echo "🌐 Website deployment verification completed"

      - name: 📋 Website deployment summary
        run: |
          echo "# 🌐 Website Deployed Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🔗 Website Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Updated:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 📦 Download Links Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The website now displays download links for:" >> $GITHUB_STEP_SUMMARY
          echo "- 🍎 **macOS**: Universal ZIP archive" >> $GITHUB_STEP_SUMMARY
          echo "- 🪟 **Windows**: MSI and EXE installers" >> $GITHUB_STEP_SUMMARY
          echo "- 🐧 **Linux**: DEB packages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🧪 Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please verify:" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Website displays correct version: ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Download links point to latest release" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Platform detection works correctly" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Release notes display properly" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "🧬 **GeneKnow Download Page** - Always up-to-date with latest releases" >> $GITHUB_STEP_SUMMARY
